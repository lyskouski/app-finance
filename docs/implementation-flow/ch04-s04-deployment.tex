% Copyright 2023 The terCAD team. All rights reserved.
% Use of this content is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.

\newpage
\subsection{Configuring Deployment}
\markboth{Gating}{Configuring Deployment}


\subsubsection{Building Web Package} \label{deploy-web}

Creating a web package is handled by \q{flutter build -v web --release} command. It'll be more strict to our code, and 
that might lead to additional failures as "non-constant instances of IconData".

\begin{lstlisting}
// ./lib/_classes/data/goal_app_data.dart
factory GoalAppData.fromJson(Map<String, dynamic> json) {
  return GoalAppData(
    icon: json['icon'] != null
      ? IconData(json['icon'], fontFamily: 'MaterialIcons') // Error
      : null,
// ... other code
\end{lstlisting}

\noindent To resolve this issue, we must ensure that all instances of IconData are used in a constant context. This can 
be partially achieved with the following modification:

\begin{lstlisting}
// ./lib/_mixins/formatter_mixin.dart
mixin FormatterMixin {
  static final Map<String, IconData> _cache = {};

  static IconData getIconFromString(int icon) {
    if (_cache.containsKey(icon)) {
      return _cache[icon]!;
    } else {
      const String fontFamily = 'MaterialIcons';
      return IconData(icon, fontFamily: fontFamily);
    }
  }
\end{lstlisting}
\begin{lstlisting}
// ./lib/_classes/data/goal_app_data.dart
factory GoalAppData.fromJson(Map<String, dynamic> json) {
  return GoalAppData(
    icon: json['icon'] != null
      ? FormatterMixin.getIconFromString(json['icon'])
      : null,
\end{lstlisting}

\noindent Now, when we call \q{getIconFromString} with a dynamic icon name, it will create an \q{IconData}-instance for 
that name, if necessary, and cache it in the \q{\_cache}-map. If the same icon name is used again in the future, the 
cached \q{IconData}-instance will be returned, allowing tree shaking to work correctly. However, we still need to 
suppress the error because tree shaking is impossible when dealing with dynamic values that cannot be analyzed 
statically at compile time:

\begin{lstlisting}[language=terminal]
flutter build -v web --release --no-tree-shake-icons
\end{lstlisting}

\noindent Another challenge arises due to the obfuscated code. This obfuscation can transform something like 
\q{AccountAppData}-type into \q{minified:iP}, which disrupts our transaction restoration process. Initially, we can 
replace "magic strings" with the \q{runtimeType}-property of classes to address this issue:

\begin{lstlisting}
// ./lib/_classes/data/transaction_log.dart
static void init(AppData store, String type, Map<String, dynamic> data) {
  final goal = GoalAppData(title: '', initial: 0.0).runtimeType.toString();
  final account = AccountAppData(title: '', type: '').runtimeType.toString();
  final bill = BillAppData(title: '', account: '', category: '').runtimeType.toString();
  final budget = BudgetAppData(title: '').runtimeType.toString();
  final curr = CurrencyAppData(title: '').runtimeType.toString();
  final typeToClass = {
    goal: (data) => GoalAppData.fromJson(data),
    account: (data) => AccountAppData.fromJson(data),
    bill: (data) => BillAppData.fromJson(data),
    budget: (data) => BudgetAppData.fromJson(data),
    curr: (data) => CurrencyAppData.fromJson(data),
  };
// ... other code
\end{lstlisting}

\noindent The main problem with this solution is that it cannot be transferred to other platforms because different 
build types (even within the same platform) may use different runtime notations for the same class. A more robust 
approach would be to adjust the JSON conversion process.

\begin{lstlisting}
// ./lib/_classes/data/abstract_app_data.dart
Map<String, Map<String, dynamic>> toFile() {
  var data = {...toJson()};
  return {
    'type': {
\end{lstlisting}
{
\xpretocmd{\lstlisting}{\vspace{-12pt}}{}{}
\begin{lstlisting}[firstnumber=6, backgroundcolor=\color{backred}]
(*@\kdiff{-}@*)      'name': runtimeType.toString(),
\end{lstlisting}
\begin{lstlisting}[firstnumber=6, backgroundcolor=\color{backgreen}]
(*@\kdiff{+}@*)      'name': getClassName(),
\end{lstlisting}
\begin{lstlisting}[firstnumber=7]
      'hash': TransactionLog.getHash(data),
    },
    'data': data,
  };
}
// Abstract, has to be implemented by each class
String getClassName();
\end{lstlisting}
}

\noindent That's done.

From now, we can't afford to ignore the "Incorrect use of ParentDataWidget" notification anymore, especially for the 
production build, as it could result in a grayed-out output instead of rendering the widgets (\cref{img:compilation-err}).

\noindent Regarding the deployment procedure, while we are following a "no-server"-approach, which means there is no any 
dedicated server to deploy into, we can improve the usage of our GitHub Pages (\ref{a-badges}):

\begin{lstlisting}[language=yaml]
name: Web Deployment

on:
  push:
    branches: main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      - uses: subosito/flutter-action@v2
        with:
          channel: 'stable'
          cache: true
      - run: flutter --version

      - name: Install Dependencies
        run: flutter pub get

      - name: Build Web Package
        run: flutter build -v web --release --no-tree-shake-icons --base-href="/app-finance/"
        ## To compile into Web Assembly (Wasm):
        # flutter build -v web --wasm ...

      - name: Add Coverage Report to the Package
        run: cp -R ./coverage ./build/web/coverage

      - name: Update GitHub Pages 
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./build/web
\end{lstlisting}

\noindent A valuable point here is to update \q{base-href} (line 24) for our Web package. It has to be aligned with 
GitHub Pages notation:

\begin{lstlisting}[language=terminal]
https://<account-name>.github.io/<repository-name>/
\end{lstlisting}

\noindent Additionally, we may buy a domain name and configure GitHub Pages to be viewed there (detailed instructions 
provided by GitHub: 
\href{https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site}{https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site}.


\subsubsection{Preparing Releases}

Anything that can be automated should be automated, and the generation of releases is no exception. Let's generate 
"Release"-page by setting a new tag (as an example, \q{git tag v1.0.1}, \q{git push origin v1.0.1}):

\begin{lstlisting}[language=yaml]
name: Project Release Artifacts
# Trigger Action by new tag recognition
on:
  push:
    tags:
      - 'v*' # Filter by pattern

# Run jobs
jobs:
  release:
    name: Create Release Page
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.tag.outputs.name }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      build_number: ${{ steps.build_number.outputs.build_number }}
    steps:
      - uses: actions/checkout@v3
        # Next argument is required to retrieve full git-history
        with:
          fetch-depth: 0
      - uses: subosito/flutter-action@v2
        with:
          channel: 'stable'
          cache: true
      - run: flutter pub get

      - name: Get Tag Name
        id: tag
        run: echo "name=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
      # Generate notes from git-history between tags
      - name: Prepare Release Notes
        run: |
          # Approach to handle multiline content 
          dart run grinder release-notes \
            --tag=v${{ steps.tag.outputs.name }} \
            --output=release_notes.log
          echo "RELEASE_NOTES<<EOF" >> $GITHUB_ENV
          while IFS= read -r line; do
            echo "$line" >> $GITHUB_ENV
          done < "release_notes.log"
          echo "EOF" >> $GITHUB_ENV
          rm release_notes.log
      # Build number as totals of commits
      - name: Set Build Number
        id: build_number
        run: echo "build_number=$(git rev-list --count HEAD)" >> $GITHUB_OUTPUT

      - name: Create Release Page
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.tag.outputs.name }}
          release_name: Release ${{ steps.tag.outputs.name }}
          body: ${{ env.RELEASE_NOTES }}
          # Prevent its publicity before a manual check
          draft: true
          prerelease: false
\end{lstlisting}

\subsubsection{Generating Artifacts}

We've prepared a release page, but what can be done in addition, is artifacts generation and attachment to our release
page. Let's do that and generate desktop runners for Macos, Linux, and Windows:

\begin{lstlisting}[language=yaml]
jobs:
  release: 
    # ... shown earlier

  build:
    name: Create ${{ matrix.target }} build
    runs-on: ${{ matrix.os }}
    needs: release
    strategy:
      fail-fast: false
      matrix:
        target: [macOS, Windows, Linux]
        include:
          - os: macos-latest
            target: macOS
            build_path: build/macos/Build/Products/Release
            asset_extension: .zip
            asset_content_type: application/zip

          - os: windows-latest
            target: Windows
            build_path: build/windows/runner/Release
            asset_extension: .zip
            asset_content_type: application/zip

          - os: ubuntu-latest
            target: Linux
            build_path: build/linux/x64/release/bundle
            asset_extension: .tar.gz
            asset_content_type: application/gzip
    steps:
      - uses: actions/checkout@v3
      - uses: subosito/flutter-action@v2
        with:
          channel: 'stable'
          cache: true
      - run: flutter pub get

      - name: Run Windows Build 
        if: matrix.target == 'Windows'
        run: |
          flutter config --enable-windows-desktop
          flutter build -v windows --release \
            --build-name=${{ needs.release.outputs.version }} \
            --build-number=${{ needs.release.outputs.build_number }}

      - name: Compress Windows Package
        if: matrix.target == 'Windows'
        run: compress-archive -Path * -DestinationPath ${env:GITHUB_WORKSPACE}/fingrom_${{ matrix.target }}${{ matrix.asset_extension }}
        working-directory: ${{ matrix.build_path }}

# ... the same steps for Linux '-v linux' and Macos '-v macos'

      - name: Upload ${{ matrix.target }} Artifact
        id: upload_release_asset
        uses: actions/upload-release-asset@latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.release.outputs.upload_url }}
          asset_path: ./fingrom_${{ matrix.target }}${{ matrix.asset_extension }}
          asset_name: fingrom_${{ matrix.target }}${{ matrix.asset_extension }}
          asset_content_type: ${{ matrix.asset_content_type }}
\end{lstlisting}

\noindent The \q{strategy}-section defines a matrix that enables to run the build job on different operating systems 
(macOS, Windows, and Linux). It specifies the operating system to be used, the path where the build results are 
expected, and the file extension with its content type of the generated artifact.

