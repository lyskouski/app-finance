% Copyright 2023 The terCAD team. All rights reserved.
% Use of this content is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.

\newpage
\subsection{Relying Versatility}
\markboth{Optimizing}{Relying Versatility}

Responsive design uses fluid layouts and media queries to dynamically adapt content to different screen sizes within a 
single codebase. In contrast, adaptive design involves creating a specific layout for each device or screen size. Each 
approach has its strengths and weaknesses, and the choice between them depends on various factors. Ideally, both 
solutions would be used: widgets should be responsive and pages (aggregative widgets called by routes) should be 
adaptive.


\subsubsection{Packaging Components}

Adopting a grid layout as part of an adaptive design strategy is a pivotal step toward creating a versatile, 
user-centric digital experience (see \cref{img:u-grid}). Grids provide the necessary structure to maintain visual 
consistency, prioritize content, and adapt seamlessly to diverse screen sizes.

In that case, let's dive into creating an external package. From the IDE, press \key{F1} -- \q{Flutter: New Project} -- 
\q{Package}. We will generate a package template with only the "lib" and "test" folders plus configuration files. Inside 
the \q{lib}-folder, the file named identically to our package works as an entry point for the package 
(\href{https://pub.dev/packages/flutter_grid_layout}{https://pub.dev/packages/flutter\_grid\_layout}):

\begin{lstlisting}
// ./lib/flutter_grid_layout.dart
library flutter_grid_layout;
// 'src'-folder for internal files that 
// might not be accessible without export
export 'src/grid_container.dart';
export 'src/grid_item.dart';
\end{lstlisting}

\img{uiux/cssgrid-flexbox}{Representation of Grid Layout \cite{Tayl18}}{img:u-grid}

\noindent The implementation resembles the previously created \q{RowWidget} in that it converts relative values into 
density-independent pixels (DIP). The \q{GridItem}-widget serves as an encapsulating entity for the original widget, 
delineating its placement within a grid matrix, while the \q{GridContainer}-widget covers all requisite calculations for 
repositioning:

\begin{lstlisting}
// ./lib/src/grid_item.dart
class GridItem extends StatelessWidget {
  final Size start;
  final Size end;
  final int zIndex;
  final Widget child;

  const GridItem({/* ... */});


  @override
  Widget build(BuildContext context) {
    return child;
  }(*@ \stopnumber @*)
}

// ./lib/src/grid_container.dart
class GridContainer extends StatelessWidget {
  final List<double?> columns;
  final List<double?> rows;
  final List<GridItem> children;

  const GridContainer({/* ... */});

  // Calculate actual DIP based on relative values
  List<double> _calc(double size, List<double?> scope) {
    // ... implementation similar to RowWidget
    // Sample, 0.5 -> 50%, 10 -> 10 DIP, null -> auto
    scope.insert(0, 0.0); // leading zero
    return scope.cast(); // null-safety
  }

  // Count length from zero-point
  List<double> _scale(List<double> scope) =>
      scope.asMap().entries.map((entry) => 
          scope.sublist(0, entry.key + 1).fold(0.0, 
              (v, e) => v + e)).toList();
  List<double> _calcWidth(width) => _calc(width, rows);
  List<double> _calcHeight(height) => _calc(height, columns);
  @override
  Widget build(BuildContext context) {
    if (columns.isEmpty || rows.isEmpty || children.isEmpty) {
      return const SizedBox();
    }
    children.sort((a, b) => a.zIndex.compareTo(b.zIndex));
    return LayoutBuilder(builder: (context, constraints) {
      final width = _scale(_calcWidth(constraints.maxWidth));
      final height = _scale(_calcHeight(constraints.maxHeight));
      return Stack(
        children: List<Widget>.generate(children.length, (index) {
          final item = children[index];
          // Calculate actual Widget size
          final itemWidth = width[item.end.width.toInt()] - 
              width[item.start.width.toInt()];
          final itemHeight = height[item.end.height.toInt()] - 
              height[item.start.height.toInt()];
          // Bound by Container
          return Container(
            // Shift by starting position
            margin: EdgeInsets.only(
              left: width[item.start.width.toInt()],
              top: height[item.start.height.toInt()],
            ),
            // Expand to the full area, alike in CSS:
            // > justify-self: stretch;
            constraints: BoxConstraints(
              maxWidth: itemWidth,   minWidth: itemWidth,
              maxHeight: itemHeight, minHeight: itemHeight,
            ),
            width: itemWidth,
            height: itemHeight,
            child: item.child,
          );
        }));
    });
  }
}
\end{lstlisting}

\noindent Using the \q{flutter pub publish}-command makes our package available on 
\href{https://pub.dev}{https://pub.dev}. It can then be aggregated into the main project using the 
\q{flutter pub add flutter\_grid\_layout}-command.


\subsubsection{Extending Behavior}

Responsiveness is paramount in engaging users across a multitude of devices and is covered by a couple of design 
concepts \cite{Frai22}: fluid layouts, media queries, and content prioritization. "Fluid layouts" use relative units, 
such as percentages, for widths and heights. This allows content to dynamically expand or contract based on the 
available screen space. Media queries are used to apply rules based on characteristics such as screen size and 
orientation. "Content prioritization" involves thoughtful ordering and repositioning of content. Based on screen 
configuration, less critical elements can adapt, be positioned differently, or be hidden.

\q{RowWidget} describes the responsiveness behavior (\issue{37}{abd9308}, \issue{185}{e1e7385}) when a direct or 
relative value is set (\q{0.0 ... 0.9(9)} values are converted into \q{0 ... 99.9(9)\%} of the available width) for some 
components and a nullable size for others (e.g., the \q{Spacer}-widget). In that case, the text section will be hidden 
if the width is less than 40 density-independent pixels (DIP):

\begin{lstlisting}
RowWidget(
  chunk: [null, 40],
  children: [
    [
      Text(
        'Sample text with a long description', 
        maxLines: 1,
        overflow: TextOverflow.ellipsis,
      ),
    ],
    [
      FloatingActionButton(
        child: Icon(Icons.add),
      ),
    ],
  ],
)
\end{lstlisting}

\noindent On the other hand, \q{GridLayer} manages \issue{158}{} different widget composition strategies: 

\begin{lstlisting}
// ./lib/routes/home_page.dart
GridLayer(
  padding: indent,
  crossAxisCount: countWidth,
  strategy:
    switch (countWidth) {
    // Rows with a single component per each
    4 => [
      [2], [3], [1], [0]
    ],
    // Three rows
    3 => [
      [2], [3], [0, 1]
    ],
    // Two rows with a column in each
    2 => [
      [2, 3], [0, 1]
    ],
    // Single column
    _ => [
      [0, 1, 2, 3]
    ]
  },
  children: [
    // Hide widget on a portrait mode
    matrix.getHeightCount(constraints) > 3
        ? goalWidget
        : ThemeHelper.emptyBox,
    billWidget,
    accountWidget,
    budgetWidget,
  ],
);
\end{lstlisting}
\begin{lstlisting}
// ./lib/widgets/_wrappers/grid_layer.dart
class GridLayer extends StatelessWidget {
  // Indent between sections
  final double padding;
  // Number of rows
  final int crossAxisCount;

  // List<Widget | Widget Function>
  final List<dynamic> children;

  // Representation strategy
  final List<dynamic> strategy;

  const GridLayer({
    super.key,
    required this.padding,
    required this.crossAxisCount,
    required this.children,
    required this.strategy,
  });

  @override
  Widget build(BuildContext context) {
    // Item can be callable to avoid unnecessary data aggregation
    // if the widget is not a part of all strategies
    fnItem(int index) => children[index] is Function 
        ? children[index]() 
        : children[index];
    // Convert widget indexes into their representation
    fnList(List<dynamic> scope) => scope.map((e) => e is List 
        ? fnList(e).cast<Widget>().toList() 
        : fnItem(e));
    return Padding(
      padding: EdgeInsets.only(left: padding, right: padding),
      child: strategy.length > 1
        ? RowWidget(
            indent: padding,
            maxWidth: ThemeHelper.getWidth(context, 2),
            chunk: List.filled(crossAxisCount, null),
            children: fnList(strategy).cast<List<Widget>>().toList()
          )
        : Column(
            children: fnList(strategy.first).cast<Widget>().toList()
          )
    );
  }
}
\end{lstlisting}
