% Copyright 2023 The terCAD team. All rights reserved.
% Use of this content is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.

\subsection{Managing Attention}
\markboth{Optimizing}{Managing Attention}

Transition across fields on a form (after pressing \key{Enter}, or tapping \key{$\rightarrow$} [Next]) eliminates the 
need for users to manually click or tap on the desired field, resulting in a smoother data entry process. Users can 
swiftly enter data in a sequential manner, mimicking the natural flow of their thoughts and reducing repetitive actions. 
This helps prevent errors and ensures that all necessary information is captured. Users can confidently complete forms, 
knowing that they are guided through the process and not likely to overlook any fields, resulting in a more error-free 
experience.

Autofocus and the enter key functionality enhance the accessibility of the application for individuals who rely on 
keyboard navigation or assistive technologies. Users who prefer or require keyboard-based interactions can easily 
navigate through the application and complete forms without the need for mouse or touch input. This inclusivity ensures 
that the application is accessible to a wider range of users, including those with motor impairments or visual 
challenges.

By implementing these features \issue{46}{}, the application maintains consistency with user expectations, reducing 
the learning curve, ensuring a familiar and intuitive experience, and allure breathe life into the application's 
usability, ushering users into a realm where efficiency reigns supreme.

For a single field it's needed just \q{autofocus: true}-attribute while when we do want to control further steps:

\begin{lstlisting}
class MyForm extends StatefulWidget {
  @override
  _MyFormState createState() => _MyFormState();
}

class _MyFormState extends State<MyForm> {
  late FocusNode _focusNode1;
  late FocusNode _focusNode2;
  late TextEditingController _controller1;
  late TextEditingController _controller2;

  @override
  void initState() {
    super.initState();
    _focusNode1 = FocusNode();
    _focusNode2 = FocusNode();
    _controller1 = TextEditingController();
    _controller2 = TextEditingController();
  }

  @override
  void dispose() {
    _focusNode1.dispose();
    _focusNode2.dispose();
    _controller1.dispose();
    _controller2.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        TextField(
          focusNode: _focusNode1,
          controller: _controller1,
          autofocus: true,
          textInputAction: TextInputAction.next,
          onEditingComplete: () =>
            FocusScope.of(context).requestFocus(_focusNode2),
        ),
        TextField(
          focusNode: _focusNode2,
          controller: _controller2,
          textInputAction: TextInputAction.done,
          onEditingComplete: () { /* final actions */ },
        ),
      ],
    );
  }
}
\end{lstlisting}

Proposal above might become overcomplicated for complex forms, so, we might take into account the usage of a state 
machine, also known as a finite-state machine (FSM). It's a conceptual model that is used to describe the behavior of a 
system in discrete states, transitions between those states, and actions associated with each state or transition.

For our case it should provide a scope of Focus Nodes and determine transition between them; to propagate it across
multiple widgets we'll use static class.

\begin{lstlisting}
class FocusController {
  // Define ignored case (when FocusNode is not defined)
  static const DEFAULT = -1;
  // List of generated nodes
  static List<FocusNode> nodes = [];
  // Index of field to focus on
  static int focus = DEFAULT;
  // Index to check previous focus
  static int _focus = DEFAULT;
  // Context is needed to request focus
  static late BuildContext _context;
  // BuildContext setter
  static void setContext(BuildContext context) {
    _context = context;
  }
  // Get focus node by index
  static FocusNode? getFocusNode(int idx) {
    // Generate nodes if missing
    // Otherwise, error: Valid value range is empty
    while (idx >= nodes.length) {
      nodes.add(FocusNode());
    }
    return idx >= 0 ? nodes[idx] : null;
  }
  // For the last field set "done" state, all above - "next"
  static TextInputAction getAction(int idx) {
    return idx >= nodes.length ? TextInputAction.done : TextInputAction.next;
  }
  // Trigger re-focus on form
  static void requestFocus() {
    // Without delay focus event will concurrent with an update request
    Future.delayed(const Duration(milliseconds: 300), () {
      // To prevent multiple triggers for the same index
      if (focus >= 0 && _focus != focus) {
        _focus = focus;
        FocusScope.of(_context).requestFocus(nodes[focus]);
        _scrollToFocusedElement(nodes[focus]);
      }
    });
  }
  // Scroll to focused element
  static void _scrollToFocusedElement(FocusNode node) {
    // Find our widget in rendered context
    final focusedNode = node.context?.findRenderObject();
    // Is needed to take indent from top (take into account widgets above)
    final firstNode = nodes[0].context?.findRenderObject();
    // Check that controller is attached to a scroll view
    bool isAttached = _controller?.hasClients ?? false;
    if (isAttached && 
        focusedNode is RenderBox && 
        firstNode is RenderBox) {
      _controller?.animateTo(
        // Get Y-axis positions and apply as a delta for animation
        focusedNode.localToGlobal(Offset.zero).dy -
            firstNode.localToGlobal(Offset.zero).dy,
        // Duration of animation
        duration: const Duration(milliseconds: 300),
        // Start animation slowly, accelerates in the middle, 
        // ... and slows down at the end
        curve: Curves.easeInOut,
      );
    }
  }
  // Reset focus to search for a new one
  static void resetFocus() {
    focus = DEFAULT;
    _focus = DEFAULT;
  }
  // Used for 'autofocus'-property on Widget
  static bool isFocused(int idx, dynamic value) {
    if ((value == null || value == '') && // not set
        idx != DEFAULT && // not equal '-1'
        // focus not set or equal to the target
        (focus == DEFAULT || focus == idx)) { 
      focus = idx;
      requestFocus();
      return true;
    }
    return false;
  }
  // Cleanup
  static void dispose() {
    // Copy of 'nodes' to avoid concurrent operations on list
    List<FocusNode> nodesCopy = List.of(nodes);
    for (FocusNode node in nodesCopy) {
      node.dispose(); // destroy Widget
      nodes.remove(node);
    }
    resetFocus();
  }
}
\end{lstlisting}

\noindent One of the problem that we might face with is an inability to open dropdowns anymore since 
\q{FocusScope.of(context).requestFocus} leads to re-build by any changed focus action. The problem is relevant to the
fact that we've been using \q{BuildContext} of our Form whereas it should be taken context from \q{DropdownButton}-element:

\begin{lstlisting}
Form(build 'context1') -> Widget(build 'context2') -> ... -> Widget(build 'context3') -> TextFormField.
\end{lstlisting}

\noindent We should trigger \q{FocusController.setContext(context);} directly for \q{context3}, otherwise re-render will 
block any additional interactions. But the right fix is to use context from our FocusNode:

\begin{lstlisting}
FocusScope.of(nodes[focus].context!).requestFocus(nodes[focus]);
\end{lstlisting}

\noindent That also gives us capability to change \q{setContext}-method in order to store index of current element 
and its value:

\begin{lstlisting}
class FocusController {
  static List<dynamic> values = [];
  static int _idx = DEFAULT;

  static Type setContext(int idx, [dynamic value]) {
    // Guard state to avoid: Valid value range is empty
    while (idx >= values.length) {
      values.add(null);
    }
    // To avoid error: Not in inclusive range -1
    if (idx >= 0) {
      values[idx] = value;
    }
    _idx = idx;
    // To use '..' cascade operator:
    // > FocusController..setContext(idx, value)..getFocusNode()
    return FocusController; 
  }
  // To be used for 'onEditingComplete' or 'onChange'
  static void onEditingComplete() {
    resetFocus();
    for (int idx = 0; idx < nodes.length; idx++) {
      isFocused(idx, values[idx]);
    }
  }
  // Optional parameters for internal usage above
  static bool isFocused([int? i, dynamic val]) {
    int idx = i ?? _idx;
    dynamic value = val ?? (_idx >= 0 ? values[idx] : null);
    if ((value == null || value == '') &&
        idx != DEFAULT &&
        (focus == DEFAULT || focus == idx)) {
      focus = idx;
      requestFocus();
      return true;
    }
    return false;
  }
\end{lstlisting}

\noindent We're continuing bravely fix errors that producing by our own, and the next might be nor obvious, nor trivial 
till the fact how exactly \q{setState}-method should be used. While we've been testing our application in build OC mode, 
an error is appeared on Android. The Flutter team tells us that everything will be cross-functional through all devices
and systems but it's only in the case when we're using a functionality as it's been expected from their side. And 
the error is relevant to a lost state of values that's been defined inside \q{StatefulWidget} class of our 
component that updated via \q{setState}-method inside \q{State}-extended class.

In our code, the issue with losing the form values state is related to the fact, that by assigning default values 
directly to the fields, those values will not be preserved when the widget is rebuilt. To maintain the form values 
state, we have to use the \q{initState}-method to initialize fields by provided values.

\begin{lstlisting}
class ExpensesTab extends StatefulWidget {
  String? account;
  // ...

  ExpensesTab({
    super.key,
    this.account,
    // ...
  });

  @override
  ExpensesTabState createState() => ExpensesTabState();
}

class ExpensesTabState extends State<ExpensesTab> {
  String? account;
  // ...

  @override
  void initState() {
    FocusController.resetFocus();
    account = widget.account;
    // ...
    super.initState();
  }
// ... other code
}
\end{lstlisting}

\noindent And finally, let's refactor taken solution to make it reliable, by storing positions during components 
initialization and making a delta scroll by their deduction (positions of the current element and the first one) -- 
\issue{164}{}, \issue{265}{172eb11}. An important tip is to assign a unique identifier (\q{id}-property) to each input 
element. Otherwise, after a compilation, all objects created from the same widget-class may be identified as one 
(\cref{img:u-grid}) due to a similar \q{hashCode}-property \issue{127}{} \issue{408}{29ac970}.

\img{uiux/focus-issue}{Visualization of a simulaneous focus on multiple fields}{img:u-focus}
