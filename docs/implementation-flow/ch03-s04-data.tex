% Copyright 2023 The terCAD team. All rights reserved.
% Use of this content is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.

\subsection{Defining Storage}
\markboth{Prototyping}{Defining Storage}

After a series of experiments aimed at modifying the visualization of content through repeated adjustments, it became clear which information is truly relevant for each item within our application \issue{17}{}. Here's the trick! In our approach, we store user input exactly as it is. All structures (bills, accounts, budgets, currency rates, invoices, transfers, etc.) are derived from this core item and are only used at runtime as a representation layer of these "transactions".

In answer to the question, "What's the purpose of transactions?" we must delve into the world of finance. Transactions 
form the basis of financial record-keeping. Their immutability, or inability to be adjusted or deleted, is dictated by 
the regulated environment of the banking industry. This ensures that historical transaction data can be trusted and is 
compliant with regulatory standards. Immutability helps maintain data integrity by minimizing the risk of manipulation 
or loss.

\noindent Although we are not a bank, the immutability of transactions provides a powerful, built-in fault tolerance 
mechanism. This ensures that every user entry is preserved exactly as it was entered. When an edit is performed, a new 
transaction is created behind the scenes. This approach safeguards against computational errors in our code. In the 
event of an error, the next patch (application upgrade) automatically restores the application's quality state, 
eliminating the need for complex migrations, conversions, or other types of data manipulation. Our focus is on 
preserving data integrity and ensuring a seamless user experience.


\subsubsection{Streaming Big Files}

Because our transaction log is measured in the millions, the best way to restore data structures from a file is to use the streaming approach. This allows us to read the file line by line, processing each line as it is read, rather than loading the entire file into memory at once. This is particularly useful for large files, as it minimizes memory usage and allows for more efficient processing.

\begin{lstlisting}
// ./lib/_classes/data/transaction_log.dart
class TransactionLog {
  // Get (or create if missing) file
  static Future<File> get _logFle async {
    final path = await getApplicationDocumentsDirectory();
    var file = File('${path.absolute.path}/app-finance.log');
    if (!(await file.exists())) {
      await file.create(recursive: true);
    }
    return file;
  }
  static void save(dynamic content) async {
    // Under the hood "content.toString()" is evaluated
    (await _logFle).writeAsString("$content\n", mode: FileMode.append);
  }
  static Future<bool> load(AppData store) async {
    Stream<String> lines = (await _logFle).openRead()
        .transform(utf8.decoder)
        .transform(const LineSplitter());
    try {
      await for (var line in lines) {
        var obj = json.decode(line);
        // ... restore object [explained further]
      }
      return true;
    } catch (e) {
      return false;
    }
  }
}
\end{lstlisting}

\noindent And adjust our constructor for \q{AppData} as follows:

\begin{lstlisting}
class AppData extends ChangeNotifier {
  bool isLoading = false;

  AppData() : super() {
    isLoading = true;
    TransactionLog.load(this)
        .then((success) => notifyListeners())
        .then((success) => isLoading = false);
  }
// ... other stuff
\end{lstlisting}


\subsubsection{Using Shared Preferences}

Now, let's take a step back and explore how shared preferences can be used as an effective alternative to saving files 
for Web and user settings across all platforms:

\begin{lstlisting}[language=terminal]
$ flutter pub add shared_preferences
\end{lstlisting}

\noindent To efficiently interact with preferences, we can use mixins, which are a powerful mechanism for reusing code 
across multiple classes. A mixin is defined using the \q{mixin}-keyword followed by its name and a set of members, such 
as properties, methods, and getters/setters. A mixin cannot be instantiated on its own. Instead, it is meant to be mixed 
into other classes using the \q{with}-keyword (it inherits all the members from the mixin). This allows the class to 
access and use the properties and methods defined in the mixin as if they were part of its own implementation.

\begin{lstlisting}
// ./lib/_mixins/shared_preferences_mixin.dart
mixin SharedPreferencesMixin {
  Future<void> setPreference(String key, String value) async {
    SharedPreferences pref = await SharedPreferences.getInstance();
    await pref.setString(key, value);
  }
  Future<String?> getPreference(String key) async {
    SharedPreferences pref = await SharedPreferences.getInstance();
    return pref.getString(key);
  }
}
\end{lstlisting}

\noindent And now we can apply it to our class(es):

\begin{lstlisting}
// ./lib/widgets/bill/expenses_tab.dart
class ExpensesTabState<T extends ExpensesTab> extends State<T>
    with SharedPreferencesMixin {(*@ \stopnumber @*)

  // ... properties and constructor
  (*@ \startnumber{10} @*)
  @override
  void initState() { // We cannot make "initState" async
    account = widget.account;
    super.initState();
    // Wait for the value, then apply it via "setState"
    getPreference('account')
        .then((value) => setState(() => account ??= value));
  }

  void updateStorage() {
    // On "save"-action store preferences
    setPreference(prefAccount, account ?? '');
// ... other code
\end{lstlisting}

\noindent What we have forgotten is that Local Storage is usually limited to 5-10 MB per domain. This limit can vary, 
and some browsers may allow more storage or give users more control over the quota. Fortunately, there is \q{Indexed DB} 
and its accompanying library -- \q{idb_shim}:

\begin{lstlisting}
// ./lib/_classes/storage/transaction_log/abstract_storage_web.dart
abstract class AbstractStorage implements InterfaceStorage {
  static int increment = 0;
  static const String storeName = 'records';
  static Database? db;

  static Future<void> _initIndexedDB() async {
    IdbFactory? idbFactory = getIdbFactory();
    if (idbFactory == null) {
      return;
    }
    db = await idbFactory.open('fingrom.db', version: 1, onUpgradeNeeded: (VersionChangeEvent event) {
      event.database.createObjectStore(storeName, keyPath: 'id');
    });
  }

  static Future<String> getSize() async {
    int size = increment * 256;
    return size.toByteSize();
  }

  static void saveRaw(String line) {
    if (db != null) {
      var store = db!.transaction(storeName, 'readwrite').objectStore(storeName);
      store.put({'id': 'log$increment', 'line': line});
    } else {
      AppPreferences.set('log$increment', line);
    }
    increment++;
  }

  static Stream<String> readRaw(Function callback) async* {
    int attempts = 0;
    do {
      int i = increment + attempts;
      String? line = await callback(i);
      if (line == null) {
        attempts++;
      } else {
        increment += attempts + 1;
        attempts = 0;
      }
      yield line ?? '';
    } while (attempts < 10);
  }

  static Stream<String> read() async* {
    increment = 0;
    await _initIndexedDB();
    await for (var line in readRaw((i) => AppPreferences.get('log$i'))) {
      yield line;
    }
    if (db != null) {
      var store = db!.transaction(storeName, 'readonly').objectStore(storeName);
      await for (var line in readRaw((i) async => ((await store.getObject('log$i')) as Map?)?['line'])) {
        yield line;
      }
    }
  }(*@ \stopnumber @*)
}

// ./lib/_classes/storage/transaction_log/abstract_storage.dart
abstract class AbstractStorage implements InterfaceStorage {
  static File? _logFile;
  static bool _isLocked = false;

  static const filePath = '.terCAD/app-finance.log';

  static Future<File> get logFle async {
    if (_logFile != null) {
      return Future.value(_logFile);
    }
    List<File> scope = [
      await getApplicationDocumentsDirectory(),
      await getApplicationSupportDirectory(),
      Directory.systemTemp,
      await getTemporaryDirectory(),
    ].map((dir) => File('${dir.absolute.path}/$filePath')).toList();
    File? file = scope.where((f) => f.existsSync()).firstOrNull;
    int i = 0;
    while (i < scope.length && file == null) {
      try {
        File tmp = scope[i];
        if (!tmp.existsSync()) {
          tmp.createSync(recursive: true);
          tmp.writeAsString("\n", mode: FileMode.append);
        }
        file = tmp;
      } catch (e) {
        i++;
      }
    }
    if (file == null) {
      throw Exception('Write access denied for: $scope.');
    }
    return _logFile = file;
  }

  static Future<String> getSize() async {
    int size = (await logFle).lengthSync();
    return size.toByteSize();
  }

  static void saveRaw(String line) {
    int retrial = 1;
    while (_isLocked && retrial < 1000) {
      sleep(Duration(microseconds: retrial * 10));
      retrial++;
    }
    _isLocked = true;
    _logFile!.writeAsStringSync("$line\n", mode: FileMode.append);
    _isLocked = false;
  }

  static Stream<String> read() async* {
    Stream<String> lines = (await logFle).openRead().transform(utf8.decoder).transform(const LineSplitter());

    await for (var line in lines) {
      yield line;
    }
  }(*@ \stopnumber @*)
}

// ./lib/_classes/storage/transaction_log.dart
import 'package:app_finance/_classes/storage/transaction_log/abstract_storage_web.dart'
    if (dart.library.io) 'package:app_finance/_classes/storage/transaction_log/abstract_storage.dart';
\end{lstlisting}

\noindent The code above demonstrates two platform-specific implementations of an abstract storage class for transaction 
logs in a Flutter application:

\begin{itemize}
\setlength{\itemsep}{3pt}
\setlength{\parskip}{0pt}
\setlength{\parsep}{0pt}
    \item Web implementation (abstract\_storage_web.dart) uses IndexedDB (via idb\_shim) or falls back to local 
    preferences for storing transaction logs. It provides methods for initializing the database, saving raw log lines, 
    and reading logs as a stream. The readRaw method supports retries to handle missing or deleted records.

    \item Native implementation (abstract\_storage.dart) uses the file system to store logs in a file. It ensures thread 
    safety with a lock when writing, supports multiple fallback directories, and streams log lines for efficient reading.

    \item The last import statement (transaction\_log.dart) uses Dart's conditional imports to select the appropriate 
    storage implementation depending on the platform (web or native).
\end{itemize}

\noindent This approach allows the application to handle large transaction logs efficiently and in a platform-agnostic 
way.


\subsubsection{Managing Local Storage}

File usage is limited by systems where our application can be used as installed instance. To support web browsers
we may rely on Local Storage. Instead of using \q{dart:html}, let's proceed with known \q{shared\_preferences} 
(\cref{img:mn-preferences}).

\begin{lstlisting}
import 'package:flutter/foundation.dart' show kIsWeb;

static void save(dynamic content) async {
  if (kIsWeb) {
    await TransactionLog().setPreference('log$increment', content.toString());
    increment++;
  } else {
    (await _logFle).writeAsString("$line\n", mode: FileMode.append);
  }
}
static Stream<String> _loadWeb() async* {
  // Some transactions might be lost or deleted
  int attempts = 0;
  do {
    int i = increment + attempts;
    var line = await TransactionLog().getPreference('log$i');
    if (line == null) {
      attempts++;
    } else {
      increment += attempts + 1;
      attempts = 0;
    }
    yield line ?? '';
    // Adding retrial approach
  } while (attempts < 10);
}
\end{lstlisting}

\img{prototyping/local-storage-web}{Usage of Local Storage by Application}{img:mn-preferences}

\begin{lstlisting}[firstnumber=29]
static Future<bool> load(AppData store) async {
  Stream<String> lines = kIsWeb
      ? _loadWeb()
      : (await _logFle).openRead()
        .transform(utf8.decoder)
        .transform(const LineSplitter());
// ... other stuff
\end{lstlisting}


\subsubsection{Using Dynamic Structures}

Once we've defined the procedure for storing transactions, let's delve into manipulating these objects. 

One approach for managing object structures with dynamic content is to dynamically set properties of a data object 
based on key-value pairs from the properties map. So, we need a method for checking if an object has specific 
properties and setting their values accordingly:

\begin{lstlisting}
class AppData {
  int? prop1;
  int? prop2;
}
void main() {
  AppData data = AppData();
  Map<String, dynamic> properties = {'prop1': 1, 'prop2': 2};

  properties.forEach((key, value) {
    if (data.hasOwnProperty(key)) {
      data.setProp(key, value);
    }
  });
}

extension ObjectExtension on Object {
  bool hasOwnProperty(String propertyName) {
    return this.runtimeType
        .declarations
        .any((declaration) => declaration.name == propertyName);
  }

  void setProp(String propertyName, dynamic value) {
    (this as dynamic)[propertyName] = value;
  }
}
\end{lstlisting}

\noindent To convert an object to a string representation and then back to the object, it can be used the 
\q{toString}-method and the \q{fromJson}-factory: 

\begin{lstlisting}
class MyClass {
  String name;
  DateTime timestamp;

  MyClass(this.timestamp, this.name);
  // Props to simple built-in types (String, double, int, bool)
  Map<String, dynamic> toJson() => {
    'name': name,
    'timestamp': timestamp.toIso8601String(),
  };
  // By using 'dart:convert' transform \q{Map}-object
  String toString() {
    return json.encode(toJson());
  }
  // Note: in factory it cannot be used class' methods (but static)
  factory MyClass.fromJson(String jsonString) {
    Map<String, dynamic> json = jsonDecode(jsonString);
    return MyClass(DateTime.parse(json['timestamp']), json['name']);
  }
}

void main() {
  MyClass myObject = MyClass(DateTime.now(), 'Sample');
  // Convert object to a string representation
  String jsonString = myObject.toString();
  print(jsonString); // {"timestamp": 123..., "name": "John"}
  // Convert string back to an object
  MyClass newObj = MyClass.fromJson(jsonString);
  print(newObj.timestamp.toIso8601String()); // '2023-10-01T...'
  print(newObj.name); // 'Sample'
}
\end{lstlisting}

\noindent In the example above, the \q{MyClass}-object has a custom \q{toString}-method that converts the object's 
properties into a stringified JSON representation. The \q{fromJson}-factory method takes a JSON string, parses it using 
\q{jsonDecode}, and creates a new \q{MyClass}-object with the extracted values. This approach provides a more 
controlled way to serialize and deserialize objects, as it maintains data consistency within the object itself,
as opposed to the previously checked solution that used an \q{extension}. So, finally our method to restore objects 
from their representation in \q{.log}-file would be the next:

\begin{lstlisting}[firstnumber=54]
// ./lib/_classes/data/transaction_log.dart
static void init(AppData store, String type, Map<String, dynamic> data) {
  final typeToClass = {
    'GoalAppData': (data) => GoalAppData.fromJson(data),
    'AccountAppData': (data) => AccountAppData.fromJson(data),
    'BillAppData': (data) => BillAppData.fromJson(data),
    'BudgetAppData': (data) => BudgetAppData.fromJson(data),
    'CurrencyAppData': (data) => CurrencyAppData.fromJson(data),
  };
  final obj = typeToClass[type];
  if (obj != null) {
    final el = obj(data);
    store.update(el.getType(), el.uuid ?? '', el, true);
  }
}
\end{lstlisting}


\subsubsection{Observing Changes}

In adherence to the SOLID principles \footnote{S - Single-responsibility Principle, O - Open-closed Principle, L - 
Liskov Substitution Principle, I - Interface Segregation Principle, D - Dependency Inversion Principle}, it is advisable 
to maintain classes that adhere to the single responsibility principle. In our case, we're interested in tracking the 
preference changes (such as theme switch between system, light, and dark) and adjust our application in accordance.

In Flutter, a \q{ValueNotifier} is a core class that allows to hold a single value and notify its listeners when the 
value changes. So, it is beneficial to establish a dedicated notifier for managing and updating the user interface:

\begin{lstlisting}
class AppTheme extends ValueNotifier<ThemeMode> with SharedPreferencesMixin {
  AppTheme(ThemeMode value) : super(value) {
    // Get from Shared Preferences current state of value
    getPreference(prefTheme).then((val) {
      if (val != null) {
        _set(val);
      }
    });
  }
  _set(String val) {
    int? idx = int.tryParse(val);
    if (idx != null) {
      // Trigger notification by value change
      value = ThemeMode.values[idx];
      notifyListeners();
    }
  }
  updateState(String value) {
    setPreference(prefTheme, value).then((_) {
      _set(value);
    });
  }
}
\end{lstlisting}

\noindent The simplest way to observe value changes can be achieved by using \q{context.watch}:

\begin{lstlisting}
void main() {
  runApp(
    // Clarify that we have more than one provider
    MultiProvider(
      providers: [
        ChangeNotifierProvider<AppData>(
          create: (_) => AppData(),
        ),
        ChangeNotifierProvider<AppTheme>(
          create: (_) => AppTheme(ThemeMode.system),
        ),
      ],
      child: MyApp(platform: platform),
    ),
  );(*@ \stopnumber @*)
}

class MyAppState extends State<MyApp> {
  Widget build(BuildContext context) {
    return MaterialApp(
      themeMode: context.watch<AppTheme>().value,
// ... other code
\end{lstlisting}

\noindent And to update the state:

\begin{lstlisting}
Provider.of<AppTheme>(context, listen: false).updateState(value);
\end{lstlisting}

\noindent The usage of asynchronous \q{getPreference} leads to unnecessary complexity and additional computational efforts:

\begin{lstlisting}[language=terminal]
User I/Choreographer( 4431): Skipped 244 frames!
  The application may be doing too much work on its main thread.
\end{lstlisting}

\noindent With this understanding, we can effortlessly resolve the issue by initializing the preferences object only 
once during the application's startup:

\begin{lstlisting}
// ./lib/main.dart
void main() async {
SharedPreferencesMixin.pref = await SharedPreferences.getInstance();(*@ \stopnumber @*)

// ./lib/_mixins/shared_preferences_mixin.dart
mixin SharedPreferencesMixin {
  static late SharedPreferences pref;
\end{lstlisting}

\noindent But we should be very accurate with what we're placing into a static variable, since, as an example, 
caching \q{AdaptiveWindowType} for our \q{ThemeHelper} leads to an infinite loop of re-rendering widgets \issue{112}{}.

An unintended loop of rendering can also occur when using \q{key: UniqueKey()} for a \q{StatelessWidget}. This happens 
because it causes the widget to be rebuilt whenever the widget tree is rebuilt due to the generation of a new 
\q{UniqueKey} for the widget.
