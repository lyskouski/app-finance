% Copyright 2023 The terCAD team. All rights reserved.
% Use of this content is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.

\subsection{Aggregating External Sources}
\markboth{Unleashing}{Aggregating External Sources}

In any application, the concept of "seamless migration" is a pivotal attribute that can significantly improve the user 
experience. It's crucial to offer convenient options for importing a broad spectrum of financial information, including 
transaction histories and detailed account statements, from various external sources, including existing market 
competitors.

The crux of this functionality lies in establishing integration channels with renowned financial institutions. Our 
application enables users to link their bank accounts, credit cards, and other financial platforms. This allows us to 
automate and systematize the import of transactional data. This integration architecture relies on APIs and secure 
connection protocols that ensure the confidentiality of sensitive financial information.

In an era characterized by the urgency of time and the demand for instantaneous solutions, the implications of such 
seamless data import are appreciated. It reinforces the idea that our application is not just another financial tool, 
but rather a resource acutely attuned to users' needs. It provides practical solutions that simplify financial 
management. Thus, it's a strategic initiative that encapsulates the essence of user-centric design. 


\subsubsection{Importing Comma-Separated Values (CSV)}

A CSV (Comma Separated Values) file is a text-based file format with a specific structure that makes storing data in a 
table easy. This format is ideal for displaying data in rows and columns and has many applications, from simple data 
storage to complex data analysis.

This format is the simplest way to export financial data from external resources and import it into our application using the \q{csv}-package \issue{35}{a425bbd}:

\begin{lstlisting}
String content = await importFile(path);
String splitter = content.contains('\r\n') ? '\r\n' : '\n';
final result = CsvToListConverter(eol: splitter).convert(content);
\end{lstlisting}


\subsubsection{Parsing Quicken Data (QIF)}

QIF files are plain text documents that adhere to a "tag-value" pair structure. Each line begins with a single character 
"tag" followed immediately by its corresponding "value", which continues until the end of the line. This format provides 
a straightforward, human-readable way to encapsulate financial data in a text-based paradigm, making it easier to 
comprehend and interpret (\href{https://en.wikipedia.org/wiki/Quicken_Interchange_Format}{https://en.wikipedia.org/wiki/Quicken\_Interchange\_Format}):

\begin{lstlisting}[language=terminal]
!Type:Bank # "!" - a section of records
D7/02/84   # "D" - date
T-500      # "T" - total amount of the transaction
N1234      # "N" - transaction identifier
C*         # "C": "*" - reconciled, "X" - cleared
M          # "M" - transaction memo
PJohn S.   # "P" - payee
L[Visa]/   # "L" - category line
^          # "^" - end of record
\end{lstlisting}

\noindent With these foundational details in hand, constructing a parser for QIF files becomes feasible 
\issue{189}{133ee9f}:

\begin{lstlisting}
FileScope _parseQif(String fileContent, [String splitter = '\n']) {
  FileScope result = [];
  final scope = fileContent.split(splitter);
  int idx = 1;
  Map<String, int> mapping = {
    'N': 0, 'T': 1, 'P': 2, 'L': 3, 'D': 4
  };
  for (int i = 0; i < scope.length; i++) {
    if (scope[i].isEmpty) {
      continue;
    }
    final key = scope[i].substring(0, 1);
    final value = scope[i].substring(1);
    if (key == '^') {
      idx++;
      result.add(List<dynamic>.filled(header.length, null));
      continue;
    }
    int? pos = mapping[key];
    if (pos != null) {
      result[idx][pos] = value;
    }
  }
  return result;
}
\end{lstlisting}


\subsubsection{Fulfilling Financial Exchange Data (OFX)}

Open Financial Exchange (OFX) files facilitate the seamless sharing of financial data between software applications and 
financial institutions. This dynamic format plays a pivotal role in streamlining the complex interactions that underpin 
modern financial management. The scope of this exchange encompasses everything from intricate transaction details to 
comprehensive account information and even bill payments.

One of the defining attributes of the OFX file format is its compatibility with a wide range of software applications. This format establishes a unified language that connects the various software platforms used by individuals and financial institutions alike. This universal language enables financial data to flow seamlessly, amplifying the efficiency of financial interactions in the digital realm. The data stored in OFX files is based on the Standard Generalized Markup Language (SGML; ISO 8879:1986) standard:

\begin{lstlisting}[language=xml]
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<OFX>
<BANKMSGSRSV1>
<STMTTRNRS>
  <STMTRS>
    <BANKTRANLIST>
      <STMTTRN>
        <TRNTYPE>DEBIT
        <DTPOSTED>***4332
        <TRNAMT>-100.00
        <FITID>1234232
        <NAME>Market Store
      </STMTTRN>
\end{lstlisting}

\noindent We might think that an \q{xml}-package would be suitable for obtaining data \issue{189}{7bd7eea}, but the command fails with an error stating that the XML file is invalid \issue{518}{}:

\begin{lstlisting}
// XmlTagException: Expected </SEVERITY>, but found </STATUS> at ...
XmlDocument.parse(content);
\end{lstlisting}

\noindent The reason is that OFX files are not strictly XML files. They contain a header section with metadata, followed 
by a body section that resembles XML but doesn't fully comply with XML standards. The body section uses SGML-like 
syntax, which is less strict than XML. To parse OFX files correctly, we need to handle the header separately and then 
parse the body as SGML-like content. We can use regular expressions to extract the relevant sections and then process 
them accordingly:

\begin{lstlisting}
  FileScope _parseOfx(String content) {
    Map<String, int> mapping = {
      'FITID': 0, // Unique ID
      'TRNAMT': amountType, // Amount
      'NAME': 2, // Description
      'DTPOSTED': dateType, // Date
    };

    final data = content.split('<STMTTRN>');
    for (int i = 1; i < data.length; i++) {
      for (var key in mapping.keys) {
        final regexp = RegExp(r'(?<=<' + key + r'>)(.*?)(?=<)');
        final match = regexp.firstMatch(data[i]);
        if (match != null) {
          // ... proceed data processing
\end{lstlisting}


\subsubsection{Supporting Banking Protocols}

The Financial Transaction Services (FinTS) protocol \issue{314}{}, previously recognized as HBCI (Home Banking Computer 
Interface), is a testament to technological advancement in digital finance. FinTS is a bank-independent interface 
meticulously designed to meet the unique requirements of German banking institutions and their customers. It enables 
them to effortlessly perform tasks such as downloading statements, initiating bank transfers, and processing direct 
debits. 

In addition to the pure protocol implementation, we can use simplified solutions, such as the Account Information 
Service (AIS) platform TryPay in Poland \issue{252}{}, to retrieve financial data from bank accounts. There is nothing 
specific to Flutter usage other than implementation in accordance with the API specification.


\subsubsection{Parsing Notifications (Android)}

As an alternative to directly implementing financial protocols for integration with banks, we could create a parser for 
incoming notifications. Note that this approach is available for Android but is restricted on iOS due to platform 
limitations.

In order to access notifications from other applications, the necessary permissions must be registered in the 
\q{AndroidManifest.xml}-file:

\begin{lstlisting}[language=xml]
<service
    android:name=".MyNotificationListenerService"
    android:label="Notification Listener"
    android:permission="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE">
    <intent-filter>
        <action android:name="android.service.notification.NotificationListenerService" />
    </intent-filter>
</service>
\end{lstlisting}

\noindent We may request this permission through the application and then listen for incoming messages by utilizing the 
\q{notification\_listener\_service}-package \issue{120}{}. This package allows our application to interact with incoming 
notifications and process them accordingly:

\begin{lstlisting}
// Check if notification permission is enabled
final bool status = await NotificationListenerService.isPermissionGranted();

// Request notification permission
final bool status = await NotificationListenerService.requestPermission();

// stream the incoming notification events
NotificationListenerService.notificationsStream.listen((event) {
  log("Current notification: $event");
});
\end{lstlisting}

\noindent By aggregating messages and utilizing a context menu through the \q{contextMenuBuilder} for the 
\q{TextField}-widget (\cref{img:f-selection}), we can equip the app with a valuable tool for a partial data 
recognition, which sections of the message identify as inputs for Bill, Income, or Transfer. 

\img{features/selection-context-menu}{Context Menu on the text selection}{img:f-selection}
