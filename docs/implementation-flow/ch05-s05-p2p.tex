% Copyright 2023 The terCAD team. All rights reserved.
% Use of this content is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.

\newpage
\subsection{Replicating Data}
\markboth{Unleashing}{Replicating Data}

Our implementation prioritizes data security and privacy by relying exclusively on in-app communication. This keeps user 
data within the app's controlled environment. While this approach enhances security, it can complicate the process of 
synchronizing data between devices. 

However, a practical approach to enabling data transfer between devices is to leverage peer-to-peer (P2P) connections 
\issue{123}{}. With P2P connections, devices communicate directly with one another, bypassing the need for a central 
server. This decentralized approach offers benefits such as data sharing, synchronization, and collaboration. It also 
places a strong emphasis on user data control because there is no central server involved. This privacy and security 
aspect is especially crucial for sensitive applications, such as personal finance tracking.

P2P networks can enable data synchronization even when devices lack an internet connection or are offline. When these 
devices regain connectivity, they can seamlessly exchange data. This feature is valuable for applications intended for 
environments with limited connectivity or in remote areas. This is why P2P connections are ideal for maintaining data 
consistency across multiple devices, ensuring that any modifications made on one device are quickly replicated on the 
others:

\begin{lstlisting}
// ./lib/_classes/herald/app_sync.dart
import 'package:peerdart/peerdart.dart';

class AppSync extends ChangeNotifier {
  /* ... properties declaration */
  AppSync() : super() {
    final id = getUuid();
    // Check if P2P enabled
    if (id != null && id.isNotEmpty) {
      enable(id);
      connect();
    }
  }
  // Get a white list of pears
  List<String> _get() {/* get list of accepted pears */ }
  // Verify connectivity
  void connect() {
    List<String> peers = _get();
    for (int i = 0; i < peers.length; i++) {
      trace(peers[i]);
    }
  }
  // Check connection to the pear by its UUID
  void trace(String id) {
    if (!peer.open) {
      peer.reconnect();
    }
    if (_status[id] == null) {
      _status[id] = SyncPeer(id, peer.connect(id));
    } else if (!_status[id]!.connection.open) {
      peer.removeConnection(_status[id]!.connection);
      _status[id]!.connection = peer.connect(id);
    }
    _status[id]!.connection.once('open').then((v) {
      _status[id]!.status = true;
      notifyListeners();
    });
    _status[id]!.connection.once('close').then((v) {
      _status[id]!.status = false;
      notifyListeners();
    });
  }
  // Registry new connection
  void add(String uuid) {
    List<String> peers = _get();
    peers.add(uuid);
  }
  // Remove pear from the white list
  void del(String uuid) {
    _status[uuid]!.connection.dispose();
    _status.remove(uuid);
  }
  // Registry callback for actions
  _listen(DataConnection conn) {
    conn.on('data').listen((data) {
      _cb.forEach((_, callback) => callback(data));
    });
    conn.on('binary').listen((data) {
      _cbBin.forEach((_, callback) => callback(data));
    });
  }
  // Send data to all registered pears
  send(String data, [String? uuid]) {
    if (uuid != null) {
      if (_status[uuid] != null && _status[uuid]!.status == true) {
        _status[uuid]!.connection.send(data);
      }
    } else {
      final keyList = _status.keys.toList();
      for (int i = 0; i < keyList.length; i++) {
        if (_status[keyList[i]]!.status == true && _status[keyList[i]]!.connection.open) {
          _status[keyList[i]]!.connection.send(data);
        } else {
          // .. postpone the message till the next 'online'-status
        }
      }
    }
  }
// .. other stuff
\end{lstlisting}

\img{features/p2p}{Configure Pear-To-Pear Connection}{img:f-p2p}

Overall, P2P connections are an efficient way to sync data between devices, enabling real-time, secure, and 
collaborative experiences across various applications. Their decentralized nature gives users greater control over their 
data, making them appealing for many modern applications. Additionally, generating and scanning \q{QR}-codes can 
facilitate sharing \issue{220}{} small amounts of data (3 KB, 7,089 numeric characters, or 4,269 alphanumeric 
characters). Near Field Communication (NFC), Wi-Fi Direct, and Bluetooth connections also enable short-range 
communication between devices.
