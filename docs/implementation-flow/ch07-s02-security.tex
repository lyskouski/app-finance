% Copyright 2023 The terCAD team. All rights reserved.
% Use of this content is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.

\subsection{Securing Information}
\markboth{Productionizing}{Securing Information}

Securing information is essential not only for financial accounting but also for any application. Not only is ensuring 
the privacy of this information ethically necessary, it is also legally mandated. Many regions have strict data 
protection laws requiring businesses to secure financial data. Examples include the GDPR in Europe and the HIPAA in the 
United States. Failure to comply can result in severe fines and legal consequences.

Users expect that their financial information will be kept secure when they entrust it to an application. Trust is 
paramount in the financial sector, and a data breach can irreparably damage a company's reputation. Therefore, financial 
institutions and applications that demonstrate strong security practices can use this as a competitive advantage.

Achieving information security requires implementing robust cybersecurity measures, such as encryption, access controls, 
and regular security audits, in applications. Ensuring app security is an ongoing endeavor that requires a proactive 
approach.


\subsubsection{Storing API keys}
\markboth{Productionizing}{Storing API keys}

Each API requires a secret key to be passed with every request for identity validation. These keys should remain 
confidential and not be part of the Git history. Even detaching credentials into a separate \q{.env}-file makes them 
susceptible to leaks. The most secure way to store secrets is as environment variables during compilation (\q{build}) or 
evaluation (\q{run}):

\begin{lstlisting}[language=terminal]
flutter build --dart-define==KEY=SECRET \
    --dart-define==KEY2=SECRET2 \
    --dart-define==KEY3=SECRET3
\end{lstlisting}

\noindent To obtain the API key from an environment:

\begin{lstlisting}
String? apiKey = String.fromEnvironment('KEY', defaultValue: null);
\end{lstlisting}

\noindent To handle dynamic values, consider using the \q{flutter\_secure\_storage}-package to securely store sensitive 
data through encrypted shared preferences (\emph{Keychain for iOS and macOS, AES encryption for Android and Windows, 
libsecret for Linux, and WebCrypto for Web}):

\begin{lstlisting}
final storage = new FlutterSecureStorage();
await storage.write(key: key, value: value);
String value = await storage.read(key: key);
\end{lstlisting}


\subsubsection{Encrypting Storage}
\markboth{Productionizing}{Encrypting Storage}

Encryption is a critical process in cybersecurity because it transforms plain text into an encoded format, thereby 
bolstering the confidentiality, integrity, and security of sensitive information. This "hiding" process can be one-way 
(taking a \q{hash}-key from a value for comparison) or bidirectional (decrypting with a cryptographic key). There are 
two primary types of encryption: symmetric and asymmetric. Symmetric encryption uses a single key for both encrypting 
and decrypting data, and examples include AES, 3-DES, and SNOW. Asymmetric encryption, also referred to as public key 
encryption, uses two keys: a public key for encryption and a private key for decryption. Examples include RSA and 
elliptic curve cryptography. Symmetric encryption uses a single shared key for encrypting and decrypting data, and all 
parties involved use this key. In contrast, asymmetric encryption employs a pair of keys: one for encryption and a 
different key for decryption.

To "disable" (at least make harder) capability to change financial transactions directly, it may be used a sum control 
\q{hash}-key \issue{58}{}:

\begin{lstlisting}
// ./lib/_classes/data/transaction_log.dart
import 'package:crypto/crypto.dart';

class TransactionLog {
  static String getHash(Map<String, dynamic> data) {
    return md5.convert(utf8.encode(data.toString())).toString();
  }

  static Future<bool> load() async {
    // ... other stuff
    await for (var line in lines) {
      var obj = json.decode(line);
      if (getHash(obj['data']) != obj['type']['hash']) {
        continue; // Corrupted data... skip
      }
\end{lstlisting}

\noindent Additionally, to protect user data, we should implement line encryption.

\begin{lstlisting}
// ./lib/_classes/data/transaction_log.dart
import 'package:encrypt/encrypt.dart';

class TransactionLog {
  static Encrypter get salt =>
      Encrypter(AES(Key.fromUtf8('32symbols-salt-for-encryption...')));

  static IV get code => IV.fromLength(8);(*@ \stopnumber @*)

  (*@ \startnumber{49} @*)
  // to encrypt content
  content = salt.encrypt(content, iv: code).base64;
  // to decrypt content
  content = salt.decrypt64(content, iv: code);
\end{lstlisting}

\noindent As a note, the usage of any external library for encryption (and not only) might be relevant to additional 
risks, as a failed upgrade ("dependency shock" \cite{Inki23}) or a breakable change (in case of \q{encrypt}-package, a 
failed decryption after a migration from 5.0.1 to 5.0.2 -- 
\href{https://github.com/leocavalcante/encrypt/issues/314}{https://github.com/leocavalcante/encrypt/issues/314}).
So, it's better to be chosen a built-in functionality even with an additional complexity; in our case, through the 
\q{dart:crypto}-library, which includes hashing, symmetric and asymmetric encryption.
