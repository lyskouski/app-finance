% Copyright 2023 The terCAD team. All rights reserved.
% Use of this content is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.

\subsection{Managing Attention}
\markboth{Optimizing}{Managing Attention}

Pressing the \key{Enter} key or tapping the \key{$\rightarrow$} [Next]) button transitions users across fields on a 
form, eliminating the need to manually click or tap on the desired field and resulting in a smoother data entry process. 
Users can enter data sequentially, which mimics the natural flow of their thoughts and reduces repetitive actions. This 
helps prevent errors and ensures that all necessary information is captured. Users can complete forms with confidence, 
knowing they are guided through the process and less likely to overlook any fields. This results in a more error-free 
experience.

The autofocus and enter key functionality enhances the accessibility of the application for individuals who rely on 
keyboard navigation or assistive technologies. Those who prefer or require keyboard-based interactions can easily 
navigate the application and complete forms without mouse or touch input. This inclusivity ensures the application is 
accessible to a wider range of users, including those with motor impairments or visual impairments.

By implementing these features \issue{46}{}, the application maintains consistency with user expectations, reducing the 
learning curve and ensuring a familiar and intuitive experience. These features breathe life into the application's 
usability, ushering users into a realm where efficiency reigns supreme.

For a single field, the only thing needed is the \q{autofocus: true} attribute. However, if we want to control further 
steps, then...

\begin{lstlisting}
class MyForm extends StatefulWidget {
  @override
  _MyFormState createState() => _MyFormState();
}

class _MyFormState extends State<MyForm> {
  late FocusNode _focusNode1;
  late FocusNode _focusNode2;
  late TextEditingController _controller1;
  late TextEditingController _controller2;

  @override
  void initState() {
    super.initState();
    _focusNode1 = FocusNode();
    _focusNode2 = FocusNode();
    _controller1 = TextEditingController();
    _controller2 = TextEditingController();
  }

  @override
  void dispose() {
    _focusNode1.dispose();
    _focusNode2.dispose();
    _controller1.dispose();
    _controller2.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        TextField(
          focusNode: _focusNode1,
          controller: _controller1,
          autofocus: true,
          textInputAction: TextInputAction.next,
          onEditingComplete: () =>
            FocusScope.of(context).requestFocus(_focusNode2),
        ),
        TextField(
          focusNode: _focusNode2,
          controller: _controller2,
          textInputAction: TextInputAction.done,
          onEditingComplete: () { /* final actions */ },
        ),
      ],
    );
  }
}
\end{lstlisting}

\noindent The above suggestion may be too complicated for complex forms, so we should consider using a state machine, 
also known as a finite-state machine (FSM). An FSM is a conceptual model that describes the behavior of a system in 
terms of its discrete states, the transitions between those states, and the actions associated with each state or 
transition.

In our case, it should provide a set of focus nodes and determine the transition between them. To propagate this across 
multiple widgets, we will use the static class.

\begin{lstlisting}
class FocusController {
  // Define ignored case (when FocusNode is not defined)
  static const DEFAULT = -1;
  // List of generated nodes
  static List<FocusNode> nodes = [];
  // Index of field to focus on
  static int focus = DEFAULT;
  // Index to check previous focus
  static int _focus = DEFAULT;
  // Context is needed to request focus
  static late BuildContext _context;
  // BuildContext setter
  static void setContext(BuildContext context) {
    _context = context;
  }
  // Get focus node by index
  static FocusNode? getFocusNode(int idx) {
    // Generate nodes if missing
    // Otherwise, error: Valid value range is empty
    while (idx >= nodes.length) {
      nodes.add(FocusNode());
    }
    return idx >= 0 ? nodes[idx] : null;
  }
  // For the last field set "done" state, all above - "next"
  static TextInputAction getAction(int idx) {
    return idx >= nodes.length ? TextInputAction.done : TextInputAction.next;
  }
  // Trigger re-focus on form
  static void requestFocus() {
    // Without delay focus event will concurrent with an update request
    Future.delayed(const Duration(milliseconds: 300), () {
      // To prevent multiple triggers for the same index
      if (focus >= 0 && _focus != focus) {
        _focus = focus;
        FocusScope.of(_context).requestFocus(nodes[focus]);
        _scrollToFocusedElement(nodes[focus]);
      }
    });
  }
  // Scroll to focused element
  static void _scrollToFocusedElement(FocusNode node) {
    // Find our widget in rendered context
    final focusedNode = node.context?.findRenderObject();
    // Is needed to take indent from top (take into account widgets above)
    final firstNode = nodes[0].context?.findRenderObject();
    // Check that controller is attached to a scroll view
    bool isAttached = _controller?.hasClients ?? false;
    if (isAttached && 
        focusedNode is RenderBox && 
        firstNode is RenderBox) {
      _controller?.animateTo(
        // Get Y-axis positions and apply as a delta for animation
        focusedNode.localToGlobal(Offset.zero).dy -
            firstNode.localToGlobal(Offset.zero).dy,
        // Duration of animation
        duration: const Duration(milliseconds: 300),
        // Start animation slowly, accelerates in the middle, 
        // ... and slows down at the end
        curve: Curves.easeInOut,
      );
    }
  }
  // Reset focus to search for a new one
  static void resetFocus() {
    focus = DEFAULT;
    _focus = DEFAULT;
  }
  // Used for 'autofocus'-property on Widget
  static bool isFocused(int idx, dynamic value) {
    if ((value == null || value == '') && // not set
        idx != DEFAULT && // not equal '-1'
        // focus not set or equal to the target
        (focus == DEFAULT || focus == idx)) { 
      focus = idx;
      requestFocus();
      return true;
    }
    return false;
  }
  // Cleanup
  static void dispose() {
    // Copy of 'nodes' to avoid concurrent operations on list
    List<FocusNode> nodesCopy = List.of(nodes);
    for (FocusNode node in nodesCopy) {
      node.dispose(); // destroy Widget
      nodes.remove(node);
    }
    resetFocus();
  }
}
\end{lstlisting}

\noindent One problem we might face is an inability to open dropdowns since \q{FocusScope.of(context).requestFocus} 
leads to rebuilding with any changed focus action. This problem arises from the fact that we have been using 
\q{BuildContext} of our form, when it should be taken from the \q{DropdownButton} element:

\begin{lstlisting}
Form(build 'context1') -> Widget(build 'context2') -> ... -> Widget(build 'context3') -> TextFormField.
\end{lstlisting}

\noindent We should trigger \q{FocusController.setContext(context)} directly for \q{context3}; otherwise, re-rendering 
will block any additional interaction. However, the correct solution is to use the context of our \q{FocusNode}:

\begin{lstlisting}
FocusScope.of(nodes[focus].context!).requestFocus(nodes[focus]);
\end{lstlisting}

\noindent This also allows us to modify the \q{setContext}-method to store the index of the current element and its 
value:

\begin{lstlisting}
class FocusController {
  static List<dynamic> values = [];
  static int _idx = DEFAULT;

  static Type setContext(int idx, [dynamic value]) {
    // Guard state to avoid: Valid value range is empty
    while (idx >= values.length) {
      values.add(null);
    }
    // To avoid error: Not in inclusive range -1
    if (idx >= 0) {
      values[idx] = value;
    }
    _idx = idx;
    // To use '..' cascade operator:
    // > FocusController..setContext(idx, value)..getFocusNode()
    return FocusController; 
  }
  // To be used for 'onEditingComplete' or 'onChange'
  static void onEditingComplete() {
    resetFocus();
    for (int idx = 0; idx < nodes.length; idx++) {
      isFocused(idx, values[idx]);
    }
  }
  // Optional parameters for internal usage above
  static bool isFocused([int? i, dynamic val]) {
    int idx = i ?? _idx;
    dynamic value = val ?? (_idx >= 0 ? values[idx] : null);
    if ((value == null || value == '') &&
        idx != DEFAULT &&
        (focus == DEFAULT || focus == idx)) {
      focus = idx;
      requestFocus();
      return true;
    }
    return false;
  }
\end{lstlisting}

\noindent We're continuing to fix errors produced by ourselves, and the next one might not be obvious or trivial until 
we figure out exactly how the \q{setState}-method should be used. While testing our application in OC build mode, an 
error appeared on Android. The Flutter team told us that everything would be cross-functional across all devices and 
systems, but only if we use the functionality as they expected. The bug is related to the loss of values defined in the 
\q{StatefulWidget} class of our component, which was updated via the \q{setState}-method in the \q{State} extended class.

In our code, the problem of losing form value state is related to assigning default values directly to fields. These 
values are not preserved when the widget is rebuilt. To preserve the state of the form values, we need to use the 
\q{initState}-method to initialize the fields with the provided values.

\begin{lstlisting}
class ExpensesTab extends StatefulWidget {
  String? account;
  // ...

  ExpensesTab({
    super.key,
    this.account,
    // ...
  });

  @override
  ExpensesTabState createState() => ExpensesTabState();
}

class ExpensesTabState extends State<ExpensesTab> {
  String? account;
  // ...

  @override
  void initState() {
    FocusController.resetFocus();
    account = widget.account;
    // ...
    super.initState();
  }
// ... other code
}
\end{lstlisting}

\noindent Finally, let's refactor the solution to make it reliable by storing the positions during component 
initialization. Then, perform a delta scroll by deducting the positions of the current and first elements -- 
\issue{164}{}, \issue{265}{172eb11}. An important tip is to assign a unique identifier (the \q{id}-property) to each 
input element. Otherwise, after compilation, all objects created from the same widget class may be identified as one (\cref{img:u-grid}) due to a similar \q{hashCode}-property -- \issue{127}{}, \issue{408}{29ac970}.

\img{uiux/focus-issue}{Visualization of a simulaneous focus on multiple fields}{img:u-focus}
