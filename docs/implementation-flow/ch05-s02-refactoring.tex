% Copyright 2023 The terCAD team. All rights reserved.
% Use of this content is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.

\subsection{Refactoring by Principles} \label{refactoring}
\markboth{Unleashing}{Refactoring by Principles}

After scrutinizing the application's "skeleton", which includes scalability and fault tolerance (see \ref{benchmark}), 
now is the time to examine its "nervous system" to ensure alignment with architectural and code style principles.\\
\\

\noindent Architectural Principles:

\begin{itemize}
  \item Architectural modularity \cite{Rich20} emphasizes breaking down a software system into distinct modules or 
  components. Each module should have a clear, well-defined purpose to promote easier development, testing, and 
  maintenance.

  \item Layered architecture \cite{Rich22} divides a system into logical layers, each of which is responsible for 
  specific tasks. This separation improves code organization and makes it easier to isolate concerns.

  \item The Separation of Concerns (SoC) principle advocates for the segregation of different aspects of functionality 
  to prevent overlap. For example, Clean Architecture \cite{Mart18}, an architectural pattern, introduces a distinctive 
  approach to structuring code, fostering a meticulously organized framework that aligns with software development 
  principles. At its core, Clean Architecture reimagines code organization into distinct layers, each with a clearly 
  defined, specialized responsibility. These layers are demarcated by robust boundaries that insulate inner layers from 
  outer influences. This strategic isolation promotes a coherent structure that safeguards the system's integrity as it 
  evolves and undergoes modifications over time. It minimizes code entanglement, making individual components and layers 
  easier to modify, debug, and maintain.

  \item Decoupled systems \cite{Kass05} have minimal dependencies between components. This flexibility allows for easier 
  upgrades, replacements, and integrations without causing ripple effects.
\end{itemize}

\noindent Code Style Principles:

\begin{itemize}
  \item A consistent code style \cite{Mart22} promotes uniformity in formatting, naming conventions, and overall 
  structure. This improves code readability and facilitates collaboration among developers.

  \item The DRY (Don't Repeat Yourself) principle encourages avoiding duplication of code.

  \item Simplicity is key (KISS). Complex solutions are more difficult to understand and maintain. Embrace simplicity 
  unless a more complex approach is necessary.

  \item "You Ain't Gonna Need It" (YAGNI). Like Occam's Razor, we should ask ourselves if it's really needed or if it's 
  just making the system more complicated \cite{LaiJ23}.

  \item Do it or get bitten in the end (DOGBITE). The solution must be built in a certain way by predicting the future 
  evolution of conditions to be met, since it's far cheaper to fix a problem upstream in the development process than 
  downstream \cite{McCo97}.

  \item The SOLID principles are an acronym representing five design principles: Single Responsibility, Open-Closed, 
  Liskov Substitution, Interface Segregation, and Dependency Inversion.
\end{itemize}

\noindent We won't discuss the details of the architectural and code style principles (see the references above) or the 
changes made in issues \issue{159}{} and \issue{217}{}. Only the semaphore approach (see equation \ref{ut-fail}) will be 
recalled, which declares refactoring only after significant code coverage. Refactoring is a process of rearchitecting 
\cite{Chec23} that makes previous decisions to restate, revise, and improve them by visualizing them in clean code. 

Note that approaches can be mixed. For example, design patterns such as VIPER (View, Presenter, Interactor, Router, 
Entity) and MVVM (Model, View, ViewModel) can be used to represent the business layer. Then, the presentation layer can 
be represented using the Atomic Design \cite{Kama22} methodology or others.

In the context of extreme programming, the methodology includes a provision for pair programming \cite{Ligu19}. This 
involves two programmers working closely together at a single workstation and communicating throughout the process of 
writing each line of code. The first developer provides automatic tests, the second implements, and the third refactors, 
with each developer switching "hats" repeatedly \cite{Bono17}.
