% Copyright 2023 The terCAD team. All rights reserved.
% Use of this content is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.

As we reflect on our progress and the tools we've refined, we ask ourselves: Is Flutter a good choice for developing 
platform-agnostic solutions? Regarding recommendations on technologies and approaches, the answer invariably begins with 
two words: "It depends".

The following example illustrates this concept. Microservices are a software architecture paradigm that decomposes an 
application into smaller, interconnected components. This approach has effectively addressed many maintenance and 
development challenges associated with monolithic architectures, in which all functions operate within a single system. 
However, this transformation has introduced a new set of requirements for engineering teams, necessitating higher levels 
of proficiency in practices \cite{John22} and processes \cite{Mugr23}.

When the goal is to deliver fully functional solutions, the focus shifts from "hot reload" capabilities to the paramount 
importance of rigorous testing and adaptability. Additionally, Flutter introduces the Dart programming language, which 
requires practice to master.

In the world of platform-agnostic application development, there are many other solutions to consider, including React 
Native, Kotlin Multiplatform, Kivy, Xamarin, Swiftic, Ionic, Apache Cordova, NativeScript, Onsen UI, Framework 7, Mobile 
Angular UI, Avalonia UI, and .NET MAUI, as well as several lesser-known options. However, we shouldn't evaluate them 
using a trivial "Hello, World!" application, as it lacks real-world significance. It's time to address a fundamental 
challenge in software development: complexity (both essential and accidental, as cited in \cite{Broo87}). We emphasize 
essential complexity by minimizing accidental complexity. To my understanding, accidental complexity refers to the 
challenges posed by the tools and frameworks we use, such as Flutter, while essential complexity is intrinsic to our 
specific implementation.

As discussed in previous pages of the book, revisiting our current implementation is as straightforward as it can be, 
with a clear declaration of simple business logic. In short, we've covered the essential, albeit less exciting, aspects 
of our application. Now, it's time to delve into integration protocols, intricate notifications, and automated, 
intelligent analysis. There's no better way to begin this journey than together. I cordially invite you to join the 
project, where we can continue to explore Flutter and its vast capabilities together. This collaborative learning 
experience promises to be exciting and educational as we delve deeper into this versatile framework.
