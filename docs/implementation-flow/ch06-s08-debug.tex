% Copyright 2023 The terCAD team. All rights reserved.
% Use of this content is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.

\subsection{Debugging Issues}
\markboth{Optimizing}{Debugging Issues}

Any application may encounter bugs and issues during after being released that might be hardly understandable 
(\cref{img:o-error}, \issue{421}{}).

\img{features/crash-stacktrace}{Firebase Chrashlytics: Failure report}{img:o-error}

\noindent Logging is one of the simplest yet most effective debugging methods in Flutter. By strategically placing 
logger statements in our code, we can trace the flow of execution and monitor changes to variables. For distributed 
applications, loggers with external storage should be used, such as Sentry
(\href{https://pub.dev/packages/sentry\_flutter}{https://pub.dev/packages/sentry\_flutter}):

\begin{lstlisting}
// Initialization
runZonedGuarded(() async {
  Future<void> main() async {
    await SentryFlutter.init(
      (o) => o.dsn = 'https://{NAME}@sentry.io/{DSN}'
    );
  }
  runApp(MyApp());
}, (ex, trace) async {
  await Sentry.captureException(ex, stackTrace: trace);
});
// ... in the code
Sentry.captureMessage(
  'A message with some info',
  withScope: (scope) {
    scope.setTag('variable', 'state');
  },
);
\end{lstlisting}

\noindent After successfully replicating the issue locally, we can place breakpoints in our code to halt execution at 
specific points. By default, the application runs in debug mode when executing the flutter run command. This allows us 
to examine variables and navigate through the code step by step, providing a more detailed inspection of the codebase. 
However, let's avoid that since the debugging process (local or production) should use a unified approach -- logs.

When using a web distribution, it becomes necessary to find a way to examine web progressive applications (WPAs). Most 
mobile browsers allow remote debugging through their developer tools. For example, in Chrome, we can use 
\href{chrome://inspect\#devices}{chrome://inspect\#devices} to access a connected phone via USB. A list of recognized 
devices will be shown underneath (see \cref{img:o-devtool}). Clicking on a device activates the Inspect panel, enabling 
detailed examination and debugging.

\img{features/devtool-devices}{Google Chrome: Devices Inspector}{img:o-devtool}

\noindent The phone may not be recognized after being connected. In that case, we should turn on "USB debugging." As for 
Android, this option is available in the \q{Developer options} in the \q{Settings} menu after clicking seven times on 
\q{Build Number} in the "About phone" submenu.

For the case of "\emph{Pending authentication: please accept debugging session on the device}", consider experimenting 
with various USB cables or connecting to different ports on a machine. Additionally, we should attempt a sequence of 
command prompts to manage the Android Debug Bridge (ADB): start from \q{adb kill-server}, followed by 
\q{adb start-server}, and finally \q{adb devices} to verify and check the status of connections, and retick the 
"Discover network targets"-checkbox. This sequence might help resolve authentication-related issues during the debugging 
session.

Another tip is to change the USB connection type to \q{MIDI} instead of file transfers. To do so, simply slide down the 
main header to access the configuration settings and make the necessary adjustment. Once the device is recognized, we 
can open the Inspect panel. This panel provides access to various tabs, including Elements, Console, Sources, Network, 
Performance, Memory, Application, and Security. The Console tab is particularly useful for monitoring logs and debugging 
information in real-time.

~

\noindent All of those things were needed to transform our initial error (\cref{img:o-error}) into a more clear trace 
(\cref{img:o-error-details}, 
\href{https://github.com/flutter/flutter/issues/138880}{https://github.com/flutter/flutter/issues/138880}):

\img{features/crash-stacktrace-details}{Google Chrome: Failure detection}{img:o-error-details}

\noindent The issue at hand is exclusive to Progressive Web App (PWA) development and is specifically related to 
transliteration corruption. This problem emerges in Flutter 3.16.0 with Dart 3.2.0 due to the two-step compilation 
process that Dart code undergoes. First, the code is compiled into optimized JavaScript for deployment. Then, the web 
platform compiles this JavaScript into native code during runtime using Just-In-Time (JIT) compilation. The intricacies 
of this compilation pipeline introduce a potential source of errors, as observed in the described scenario.

There was a brief mention previously of the option to build with Web Assembly (see \ref{deploy-web}). Web Assembly is a 
low-level format residing closer to the machine code abstraction level than JavaScript does. This proximity results in 
faster startup times and a more predictable execution flow. Using Web Assembly eliminates the need for the two-step 
compilation process, making it a viable solution amidst various uncertainties. However, it's worth noting that Web 
Assembly is still experimental, having been introduced in 2020, and introduces its own set of considerations and 
potential trade-offs.

Occasionally, when an urgent solution is required, the quickest remedy may be to revert the changes made to \issue{424}{}. In our context, this means downgrading Flutter to an earlier version, which can be retrieved from CI/CD. This can be done through FVM (see reference \ref{sdk}) or by following a step-by-step process:

\begin{lstlisting}[language=terminal]
# Check the current state
$ flutter doctor
[V] Flutter (Channel stable, 3.16.0, on ...)
# Identify the SDK location
$ which flutter
/home/Programs/flutter/flutter/bin//flutter
$ cd /home/Programs/flutter/flutter/bin
$ git fetch --tags
$ git checkout 3.13.9
$ flutter doctor
# Update metadata
$ cd ~/project
$ flutter create .
\end{lstlisting}

\noindent From here on out, we need to specify the SDK version in all of our CI/CD processes:

\begin{lstlisting}[language=yaml]
- uses: subosito/flutter-action@v2
  with:
\end{lstlisting}
{
\xpretocmd{\lstlisting}{\vspace{-12pt}}{}{}
\begin{lstlisting}[firstnumber=2, backgroundcolor=\color{backred}]
(*@\kdiff{-}@*)      channel: 'stable'
\end{lstlisting}
\begin{lstlisting}[firstnumber=2, backgroundcolor=\color{backgreen}]
(*@\kdiff{+}@*)      flutter-version: 3.13.9
\end{lstlisting}
\begin{lstlisting}
    cache: true
\end{lstlisting}
}

\noindent To restore back the state:

\begin{lstlisting}[language=terminal]
$ flutter channel stable
$ flutter upgrade
\end{lstlisting}

\noindent However, addressing the original issue remains elusive as it extends beyond our sphere of influence. Even if 
we will revert almost all the changes made between two releases of the application... even by going further to 
primordial, the error would persist. This is because we have the control over the initial compilation of the web 
application but a lack of any at the Just-In-Time (JIT) transformation that occurs on a mobile device as a Progressive 
Web App (PWA).

Interestingly, this challenge led us to an unmanageable error state, which required prompt action due to freezes 
associated with each opened selector for anyone using the app as a PWA. During the reimplementation of the component, we 
discovered a key feature: seamless data transfer between pages. This capability allows us to pass not only raw data but also functions that define the representation of that data. This is particularly useful when we want to customize how data is displayed without altering the underlying data structure.

\begin{lstlisting}
// ./lib/design/form/list_selector.dart
void onTap(BuildContext context) async {
  focusController.onFocus(this);
  final result = await Navigator.push(
    context,
    MaterialPageRoute(
      builder: (context) => ListSelectorPage(
        options: options,
        result: value,
        tooltip: tooltip,
        itemBuilder: getItemBuilder(),
      ),
    ),
  );
  widget.setState(result); (*@ \stopnumber @*)
}

// ./lib/design/form/list_selector_page.dart
onPressed: () => nav.pop<T?>(result as T?),
\end{lstlisting}

\noindent We have successfully expanded our capabilities by transmitting raw data and encapsulating a representation 
state within a function. Furthermore, we have improved our component by adding a clear-state button and the ability to 
automatically select the first element when the Enter key is pressed \issue{424}{}. Much like adept problem solvers, we 
can commend ourselves for navigating challenges and enhancing our system (see \cref{img:o-selector}).

\img{features/selector}{Customized selector's popup window}{img:o-selector}

\noindent Note that we have refrained from using breakpoints to debug our application step by step through the IDE. 
Let's avoid modern programming practices that lead to inadvertent complications in concurrency and parallelism. A 
breakpoint could influence the app's flow, causing even greater confusion. When we reach the point where we feel unable 
to comprehend the code, the problem might not actually be there. Instead, we should rely on logs to trace the application's behavior. By strategically placing logging statements, we can monitor the flow of execution and identify where things might be going wrong without altering the program's state or timing.
